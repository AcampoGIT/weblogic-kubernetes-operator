/* Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved. */
/*
 * WebLogicDomain
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package oracle.kubernetes.operator.domain.model.oracle.kubernetes.weblogic.domain.v1;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.joda.time.DateTime;

import com.google.gson.annotations.SerializedName;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import oracle.kubernetes.operator.domain.model.oracle.kubernetes.weblogic.domain.v1.DomainCondition;

/**
 * DomainStatus represents information about the status of a domain. Status may
 * trail the actual state of a system.
 */
@ApiModel(description = "DomainStatus represents information about the status of a domain. Status may trail the actual state of a system.")

public class DomainStatus {
  @SerializedName("conditions")
  private List<DomainCondition> conditions = null;

  @SerializedName("message")
  private String message = null;

  @SerializedName("reason")
  private String reason = null;

  @SerializedName("availableServers")
  private List<String> availableServers = null;

  @SerializedName("unavailableServers")
  private List<String> unavailableServers = null;

  @SerializedName("availableClusters")
  private List<String> availableClusters = null;

  @SerializedName("unavailableClusters")
  private List<String> unavailableClusters = null;

  @SerializedName("startTime")
  private DateTime startTime = null;

  public DomainStatus conditions(List<DomainCondition> conditions) {
    this.conditions = conditions;
    return this;
  }

  public DomainStatus addConditionsItem(DomainCondition conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<DomainCondition>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

  /**
   * Current service state of domain.
   * 
   * @return conditions
   **/
  @ApiModelProperty(value = "Current service state of domain.")
  public List<DomainCondition> getConditions() {
    return conditions;
  }

  public void setConditions(List<DomainCondition> conditions) {
    this.conditions = conditions;
  }

  public DomainStatus message(String message) {
    this.message = message;
    return this;
  }

  /**
   * A human readable message indicating details about why the domain is in this
   * condition.
   * 
   * @return message
   **/
  @ApiModelProperty(value = "A human readable message indicating details about why the domain is in this condition.")
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public DomainStatus reason(String reason) {
    this.reason = reason;
    return this;
  }

  /**
   * A brief CamelCase message indicating details about why the domain is in this
   * state.
   * 
   * @return reason
   **/
  @ApiModelProperty(value = "A brief CamelCase message indicating details about why the domain is in this state.")
  public String getReason() {
    return reason;
  }

  public void setReason(String reason) {
    this.reason = reason;
  }

  public DomainStatus availableServers(List<String> availableServers) {
    this.availableServers = availableServers;
    return this;
  }

  public DomainStatus addAvailableServersItem(String availableServersItem) {
    if (this.availableServers == null) {
      this.availableServers = new ArrayList<String>();
    }
    this.availableServers.add(availableServersItem);
    return this;
  }

  /**
   * List of specific server instances that are available.
   * 
   * @return availableServers
   **/
  @ApiModelProperty(value = "List of specific server instances that are available.")
  public List<String> getAvailableServers() {
    return availableServers;
  }

  public void setAvailableServers(List<String> availableServers) {
    this.availableServers = availableServers;
  }

  public DomainStatus unavailableServers(List<String> unavailableServers) {
    this.unavailableServers = unavailableServers;
    return this;
  }

  public DomainStatus addUnavailableServersItem(String unavailableServersItem) {
    if (this.unavailableServers == null) {
      this.unavailableServers = new ArrayList<String>();
    }
    this.unavailableServers.add(unavailableServersItem);
    return this;
  }

  /**
   * List of specific server instances that are configured to be available but
   * that are either not yet available or have failed.
   * 
   * @return unavailableServers
   **/
  @ApiModelProperty(value = "List of specific server instances that are configured to be available but that are either not yet available or have failed.")
  public List<String> getUnavailableServers() {
    return unavailableServers;
  }

  public void setUnavailableServers(List<String> unavailableServers) {
    this.unavailableServers = unavailableServers;
  }

  public DomainStatus availableClusters(List<String> availableClusters) {
    this.availableClusters = availableClusters;
    return this;
  }

  public DomainStatus addAvailableClustersItem(String availableClustersItem) {
    if (this.availableClusters == null) {
      this.availableClusters = new ArrayList<String>();
    }
    this.availableClusters.add(availableClustersItem);
    return this;
  }

  /**
   * List of specific cluster instances where the configured number of replicas
   * are now available.
   * 
   * @return availableClusters
   **/
  @ApiModelProperty(value = "List of specific cluster instances where the configured number of replicas are now available.")
  public List<String> getAvailableClusters() {
    return availableClusters;
  }

  public void setAvailableClusters(List<String> availableClusters) {
    this.availableClusters = availableClusters;
  }

  public DomainStatus unavailableClusters(List<String> unavailableClusters) {
    this.unavailableClusters = unavailableClusters;
    return this;
  }

  public DomainStatus addUnavailableClustersItem(String unavailableClustersItem) {
    if (this.unavailableClusters == null) {
      this.unavailableClusters = new ArrayList<String>();
    }
    this.unavailableClusters.add(unavailableClustersItem);
    return this;
  }

  /**
   * List of specific cluster instances to configured to be available but for
   * which one or more of the necessary replicas are either not yet available or
   * have failed.
   * 
   * @return unavailableClusters
   **/
  @ApiModelProperty(value = "List of specific cluster instances to configured to be available but for which one or more of the necessary replicas are either not yet available or have failed.")
  public List<String> getUnavailableClusters() {
    return unavailableClusters;
  }

  public void setUnavailableClusters(List<String> unavailableClusters) {
    this.unavailableClusters = unavailableClusters;
  }

  public DomainStatus startTime(DateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * RFC 3339 date and time at which the operator started the domain. This will be
   * when the operator begins processing and will precede when the various servers
   * or clusters are available.
   * 
   * @return startTime
   **/
  @ApiModelProperty(value = "RFC 3339 date and time at which the operator started the domain.  This will be when the operator begins processing and will procede when the various servers or clusters are available.")
  public DateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(DateTime startTime) {
    this.startTime = startTime;
  }

  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DomainStatus oracleKubernetesWeblogicDomainV1DomainStatus = (DomainStatus) o;
    return Objects.equals(this.conditions, oracleKubernetesWeblogicDomainV1DomainStatus.conditions)
        && Objects.equals(this.message, oracleKubernetesWeblogicDomainV1DomainStatus.message)
        && Objects.equals(this.reason, oracleKubernetesWeblogicDomainV1DomainStatus.reason)
        && Objects.equals(this.availableServers, oracleKubernetesWeblogicDomainV1DomainStatus.availableServers)
        && Objects.equals(this.unavailableServers, oracleKubernetesWeblogicDomainV1DomainStatus.unavailableServers)
        && Objects.equals(this.availableClusters, oracleKubernetesWeblogicDomainV1DomainStatus.availableClusters)
        && Objects.equals(this.unavailableClusters, oracleKubernetesWeblogicDomainV1DomainStatus.unavailableClusters)
        && Objects.equals(this.startTime, oracleKubernetesWeblogicDomainV1DomainStatus.startTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(conditions, message, reason, availableServers, unavailableServers, availableClusters,
        unavailableClusters, startTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DomainStatus {\n");

    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    reason: ").append(toIndentedString(reason)).append("\n");
    sb.append("    availableServers: ").append(toIndentedString(availableServers)).append("\n");
    sb.append("    unavailableServers: ").append(toIndentedString(unavailableServers)).append("\n");
    sb.append("    availableClusters: ").append(toIndentedString(availableClusters)).append("\n");
    sb.append("    unavailableClusters: ").append(toIndentedString(unavailableClusters)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
